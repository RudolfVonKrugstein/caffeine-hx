diff -ruwN -U 20 lua-5.1.3-orig/src/lcode.c lua-5.1.3/src/lcode.c
--- lua-5.1.3-orig/src/lcode.c	2007-12-28 08:32:23.000000000 -0700
+++ lua-5.1.3/src/lcode.c	2008-03-12 06:58:14.000000000 -0600
@@ -633,88 +633,103 @@
 
 
 static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
   lua_Number v1, v2, r;
   if (!isnumeral(e1) || !isnumeral(e2)) return 0;
   v1 = e1->u.nval;
   v2 = e2->u.nval;
   switch (op) {
     case OP_ADD: r = luai_numadd(v1, v2); break;
     case OP_SUB: r = luai_numsub(v1, v2); break;
     case OP_MUL: r = luai_nummul(v1, v2); break;
     case OP_DIV:
       if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
       r = luai_numdiv(v1, v2); break;
     case OP_MOD:
       if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
       r = luai_nummod(v1, v2); break;
     case OP_POW: r = luai_numpow(v1, v2); break;
     case OP_UNM: r = luai_numunm(v1); break;
     case OP_LEN: return 0;  /* no constant folding for 'len' */
+    case OP_BOR: luai_logor(r, v1, v2); break;
+    case OP_BAND: luai_logand(r, v1, v2); break;
+    case OP_BXOR: luai_logxor(r, v1, v2);  break;
+    case OP_BRSHFT: luai_logrshft(r, v1, v2); break;
+    case OP_BLSHFT: luai_loglshft(r, v1, v2); break;
+    case OP_BNOT: luai_lognot(r, v1); break;
+    case OP_INTDIV:
+      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+      r = luai_numintdiv(v1, v2); break;
     default: lua_assert(0); r = 0; break;
   }
   if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
   e1->u.nval = r;
   return 1;
 }
 
 
 static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
   if (constfolding(op, e1, e2))
     return;
   else {
-    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
+	int o2 = (op != OP_UNM && op != OP_LEN && op != OP_BNOT) ? luaK_exp2RK(fs, e2) : 0;
     int o1 = luaK_exp2RK(fs, e1);
     if (o1 > o2) {
       freeexp(fs, e1);
       freeexp(fs, e2);
     }
     else {
       freeexp(fs, e2);
       freeexp(fs, e1);
     }
     e1->u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
     e1->k = VRELOCABLE;
   }
 }
 
 
 static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
                                                           expdesc *e2) {
   int o1 = luaK_exp2RK(fs, e1);
   int o2 = luaK_exp2RK(fs, e2);
   freeexp(fs, e2);
   freeexp(fs, e1);
   if (cond == 0 && op != OP_EQ) {
     int temp;  /* exchange args to replace by `<' or `<=' */
     temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
     cond = 1;
   }
   e1->u.s.info = condjump(fs, op, cond, o1, o2);
   e1->k = VJMP;
 }
 
 
 void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
   expdesc e2;
   e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
   switch (op) {
+    case OPR_BNOT: {
+      if (e->k == VK)
+        luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
+      codearith(fs, OP_BNOT, e, &e2);
+      break;
+    }
     case OPR_MINUS: {
       if (!isnumeral(e))
         luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
       codearith(fs, OP_UNM, e, &e2);
       break;
     }
     case OPR_NOT: codenot(fs, e); break;
     case OPR_LEN: {
       luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
       codearith(fs, OP_LEN, e, &e2);
       break;
     }
     default: lua_assert(0);
   }
 }
 
 
 void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
   switch (op) {
     case OPR_AND: {
@@ -767,40 +782,46 @@
         e1->k = VRELOCABLE; e1->u.s.info = e2->u.s.info;
       }
       else {
         luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
         codearith(fs, OP_CONCAT, e1, e2);
       }
       break;
     }
     case OPR_ADD: codearith(fs, OP_ADD, e1, e2); break;
     case OPR_SUB: codearith(fs, OP_SUB, e1, e2); break;
     case OPR_MUL: codearith(fs, OP_MUL, e1, e2); break;
     case OPR_DIV: codearith(fs, OP_DIV, e1, e2); break;
     case OPR_MOD: codearith(fs, OP_MOD, e1, e2); break;
     case OPR_POW: codearith(fs, OP_POW, e1, e2); break;
     case OPR_EQ: codecomp(fs, OP_EQ, 1, e1, e2); break;
     case OPR_NE: codecomp(fs, OP_EQ, 0, e1, e2); break;
     case OPR_LT: codecomp(fs, OP_LT, 1, e1, e2); break;
     case OPR_LE: codecomp(fs, OP_LE, 1, e1, e2); break;
     case OPR_GT: codecomp(fs, OP_LT, 0, e1, e2); break;
     case OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); break;
+    case OPR_BOR: codearith(fs, OP_BOR, e1, e2); break;
+    case OPR_BAND: codearith(fs, OP_BAND, e1, e2); break;
+    case OPR_BXOR: codearith(fs, OP_BXOR, e1, e2); break;
+    case OPR_BLSHFT: codearith(fs, OP_BLSHFT, e1, e2); break;
+    case OPR_BRSHFT: codearith(fs, OP_BRSHFT, e1, e2); break;
+    case OPR_INTDIV: codearith(fs, OP_INTDIV, e1, e2); break;
     default: lua_assert(0);
   }
 }
 
 
 void luaK_fixline (FuncState *fs, int line) {
   fs->f->lineinfo[fs->pc - 1] = line;
 }
 
 
 static int luaK_code (FuncState *fs, Instruction i, int line) {
   Proto *f = fs->f;
   dischargejpc(fs);  /* `pc' will change */
   /* put new instruction in code array */
   luaM_growvector(fs->L, f->code, fs->pc, f->sizecode, Instruction,
                   MAX_INT, "code size overflow");
   f->code[fs->pc] = i;
   /* save corresponding line information */
   luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                   MAX_INT, "code size overflow");
diff -ruwN -U 20 lua-5.1.3-orig/src/lcode.h lua-5.1.3/src/lcode.h
--- lua-5.1.3-orig/src/lcode.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/lcode.h	2008-03-12 06:58:14.000000000 -0600
@@ -8,50 +8,50 @@
 #define lcode_h
 
 #include "llex.h"
 #include "lobject.h"
 #include "lopcodes.h"
 #include "lparser.h"
 
 
 /*
 ** Marks the end of a patch list. It is an invalid value both as an absolute
 ** address, and as a list link (would link an element to itself).
 */
 #define NO_JUMP (-1)
 
 
 /*
 ** grep "ORDER OPR" if you change these enums
 */
 typedef enum BinOpr {
   OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_BOR, OPR_BAND, OPR_BXOR, OPR_BLSHFT, OPR_BRSHFT, OPR_INTDIV,
   OPR_CONCAT,
   OPR_NE, OPR_EQ,
   OPR_LT, OPR_LE, OPR_GT, OPR_GE,
   OPR_AND, OPR_OR,
   OPR_NOBINOPR
 } BinOpr;
 
 
-typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
-
+typedef enum UnOpr { OPR_BNOT, OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
 
 #define getcode(fs,e)	((fs)->f->code[(e)->u.s.info])
 
 #define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
 
 #define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
 
 LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
 LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
 LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
 LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
 LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
 LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
 LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
 LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
 LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
 LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
 LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
 LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
 LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
diff -ruwN -U 20 lua-5.1.3-orig/src/ldebug.c lua-5.1.3/src/ldebug.c
--- lua-5.1.3-orig/src/ldebug.c	2007-12-28 08:32:23.000000000 -0700
+++ lua-5.1.3/src/ldebug.c	2008-03-12 06:58:14.000000000 -0600
@@ -559,40 +559,46 @@
                 op, kind, name, t);
   else
     luaG_runerror(L, "attempt to %s a %s value", op, t);
 }
 
 
 void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
   if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
   lua_assert(!ttisstring(p1) && !ttisnumber(p1));
   luaG_typeerror(L, p1, "concatenate");
 }
 
 
 void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
   TValue temp;
   if (luaV_tonumber(p1, &temp) == NULL)
     p2 = p1;  /* first operand is wrong */
   luaG_typeerror(L, p2, "perform arithmetic on");
 }
 
+void luaG_logicerror (lua_State *L, const TValue *p1, const TValue *p2) {
+  TValue temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform bitwise operation on");
+}
 
 int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
   const char *t1 = luaT_typenames[ttype(p1)];
   const char *t2 = luaT_typenames[ttype(p2)];
   if (t1[2] == t2[2])
     luaG_runerror(L, "attempt to compare two %s values", t1);
   else
     luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
   return 0;
 }
 
 
 static void addinfo (lua_State *L, const char *msg) {
   CallInfo *ci = L->ci;
   if (isLua(ci)) {  /* is Lua code? */
     char buff[LUA_IDSIZE];  /* add file:line information */
     int line = currentline(L, ci);
     luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
     luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
   }
diff -ruwN -U 20 lua-5.1.3-orig/src/ldebug.h lua-5.1.3/src/ldebug.h
--- lua-5.1.3-orig/src/ldebug.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/ldebug.h	2008-03-12 06:58:14.000000000 -0600
@@ -12,22 +12,24 @@
 
 
 #define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
 
 #define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
 
 #define resethookcount(L)	(L->hookcount = L->basehookcount)
 
 
 LUAI_FUNC void luaG_typeerror (lua_State *L, const TValue *o,
                                              const char *opname);
 LUAI_FUNC void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
 LUAI_FUNC void luaG_aritherror (lua_State *L, const TValue *p1,
                                               const TValue *p2);
 LUAI_FUNC int luaG_ordererror (lua_State *L, const TValue *p1,
                                              const TValue *p2);
 LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);
 LUAI_FUNC void luaG_errormsg (lua_State *L);
 LUAI_FUNC int luaG_checkcode (const Proto *pt);
 LUAI_FUNC int luaG_checkopenop (Instruction i);
+LUAI_FUNC void luaG_logicerror (lua_State *L, const TValue *p1,
+                                              const TValue *p2);
 
 #endif
diff -ruwN -U 20 lua-5.1.3-orig/src/ldo.c lua-5.1.3/src/ldo.c
--- lua-5.1.3-orig/src/ldo.c	2008-01-18 15:31:22.000000000 -0700
+++ lua-5.1.3/src/ldo.c	2008-03-12 06:57:21.000000000 -0600
@@ -23,48 +23,40 @@
 #include "lopcodes.h"
 #include "lparser.h"
 #include "lstate.h"
 #include "lstring.h"
 #include "ltable.h"
 #include "ltm.h"
 #include "lundump.h"
 #include "lvm.h"
 #include "lzio.h"
 
 
 
 
 /*
 ** {======================================================
 ** Error-recovery functions
 ** =======================================================
 */
 
 
-/* chain list of long jump buffers */
-struct lua_longjmp {
-  struct lua_longjmp *previous;
-  luai_jmpbuf b;
-  volatile int status;  /* error code */
-};
-
-
 void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
   switch (errcode) {
     case LUA_ERRMEM: {
       setsvalue2s(L, oldtop, luaS_newliteral(L, MEMERRMSG));
       break;
     }
     case LUA_ERRERR: {
       setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
       break;
     }
     case LUA_ERRSYNTAX:
     case LUA_ERRRUN: {
       setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
       break;
     }
   }
   L->top = oldtop + 1;
 }
 
 
@@ -93,40 +85,41 @@
 
 void luaD_throw (lua_State *L, int errcode) {
   if (L->errorJmp) {
     L->errorJmp->status = errcode;
     LUAI_THROW(L, L->errorJmp);
   }
   else {
     L->status = cast_byte(errcode);
     if (G(L)->panic) {
       resetstack(L, errcode);
       lua_unlock(L);
       G(L)->panic(L);
     }
     exit(EXIT_FAILURE);
   }
 }
 
 
 int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
   struct lua_longjmp lj;
+  lj.type = JMPTYPE_LONGJMP;
   lj.status = 0;
   lj.previous = L->errorJmp;  /* chain new error handler */
   L->errorJmp = &lj;
   LUAI_TRY(L, &lj,
     (*f)(L, ud);
   );
   L->errorJmp = lj.previous;  /* restore old error handler */
   return lj.status;
 }
 
 /* }====================================================== */
 
 
 static void correctstack (lua_State *L, TValue *oldstack) {
   CallInfo *ci;
   GCObject *up;
   L->top = (L->top - oldstack) + L->stack;
   for (up = L->openupval; up != NULL; up = up->gch.next)
     gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
   for (ci = L->base_ci; ci <= L->ci; ci++) {
diff -ruwN -U 20 lua-5.1.3-orig/src/ldo.h lua-5.1.3/src/ldo.h
--- lua-5.1.3-orig/src/ldo.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/ldo.h	2008-03-12 06:57:21.000000000 -0600
@@ -1,34 +1,55 @@
 /*
 ** $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
 
 #ifndef ldo_h
 #define ldo_h
 
 
 #include "lobject.h"
 #include "lstate.h"
 #include "lzio.h"
 
+#include <setjmp.h>
+
+#define JMPTYPE_LONGJMP         0
+#define JMPTYPE_TRY             1
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  luai_jmpbuf b;
+  volatile int status;  /* error code */
+
+  int type;             /* JMPTYPE_* */
+  Instruction *pc;
+  ptrdiff_t old_ci;
+  lu_byte old_allowhooks;
+  ptrdiff_t old_errfunc;
+  int old_top;
+  int old_nexeccalls;
+  unsigned short oldnCcalls;
+};
+
 
 #define luaD_checkstack(L,n)	\
   if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) \
     luaD_growstack(L, n); \
   else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
 
 
 #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
 
 #define savestack(L,p)		((char *)(p) - (char *)L->stack)
 #define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
 
 #define saveci(L,p)		((char *)(p) - (char *)L->base_ci)
 #define restoreci(L,n)		((CallInfo *)((char *)L->base_ci + (n)))
 
 
 /* results from luaD_precall */
 #define PCRLUA		0	/* initiated a call to a Lua function */
 #define PCRC		1	/* did a call to a C function */
 #define PCRYIELD	2	/* C funtion yielded */
diff -ruwN -U 20 lua-5.1.3-orig/src/llex.c lua-5.1.3/src/llex.c
--- lua-5.1.3-orig/src/llex.c	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/llex.c	2008-03-12 07:27:29.000000000 -0600
@@ -18,45 +18,45 @@
 #include "llex.h"
 #include "lobject.h"
 #include "lparser.h"
 #include "lstate.h"
 #include "lstring.h"
 #include "ltable.h"
 #include "lzio.h"
 
 
 
 #define next(ls) (ls->current = zgetc(ls->z))
 
 
 
 
 #define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
 
 
 /* ORDER RESERVED */
 const char *const luaX_tokens [] = {
-    "and", "break", "do", "else", "elseif",
+    "and", "break", "catch", "do", "else", "elseif",
     "end", "false", "for", "function", "if",
     "in", "local", "nil", "not", "or", "repeat",
-    "return", "then", "true", "until", "while",
-    "..", "...", "==", ">=", "<=", "~=",
+    "return", "then", "true", "try", "until", "while",
+    "..", "...", "==", ">=", ">>", "<=", "<<", "^^", "~=", "!=",
     "<number>", "<name>", "<string>", "<eof>",
     NULL
 };
 
 
 #define save_and_next(ls) (save(ls, ls->current), next(ls))
 
 
 static void save (LexState *ls, int c) {
   Mbuffer *b = ls->buff;
   if (b->n + 1 > b->buffsize) {
     size_t newsize;
     if (b->buffsize >= MAX_SIZET/2)
       luaX_lexerror(ls, "lexical element too long", 0);
     newsize = b->buffsize * 2;
     luaZ_resizebuffer(ls->L, b, newsize);
   }
   b->buffer[b->n++] = cast(char, c);
 }
 
@@ -356,47 +356,59 @@
         while (!currIsNewline(ls) && ls->current != EOZ)
           next(ls);
         continue;
       }
       case '[': {
         int sep = skip_sep(ls);
         if (sep >= 0) {
           read_long_string(ls, seminfo, sep);
           return TK_STRING;
         }
         else if (sep == -1) return '[';
         else luaX_lexerror(ls, "invalid long string delimiter", TK_STRING);
       }
       case '=': {
         next(ls);
         if (ls->current != '=') return '=';
         else { next(ls); return TK_EQ; }
       }
       case '<': {
         next(ls);
-        if (ls->current != '=') return '<';
-        else { next(ls); return TK_LE; }
+        if (ls->current == '=') { next(ls); return TK_LE; }
+        else if (ls->current == '<') { next(ls); return TK_LSHFT; }
+        else  return '<';
       }
       case '>': {
         next(ls);
-        if (ls->current != '=') return '>';
-        else { next(ls); return TK_GE; }
+        if (ls->current == '=') { next(ls); return TK_GE; }
+        else if (ls->current == '>') { next(ls); return TK_RSHFT; }
+        else return '>';
+      }
+      case '^': {
+        next(ls);
+        if (ls->current != '|') return '^';
+        else { next(ls); return TK_XOR; }
+      }
+      case '!': {
+        next(ls);
+        if (ls->current != '=') return '!';
+        else { next(ls); return TK_NE; }
       }
       case '~': {
         next(ls);
         if (ls->current != '=') return '~';
         else { next(ls); return TK_NE; }
       }
       case '"':
       case '\'': {
         read_string(ls, ls->current, seminfo);
         return TK_STRING;
       }
       case '.': {
         save_and_next(ls);
         if (check_next(ls, ".")) {
           if (check_next(ls, "."))
             return TK_DOTS;   /* ... */
           else return TK_CONCAT;   /* .. */
         }
         else if (!isdigit(ls->current)) return '.';
         else {
diff -ruwN -U 20 lua-5.1.3-orig/src/llex.h lua-5.1.3/src/llex.h
--- lua-5.1.3-orig/src/llex.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/llex.h	2008-03-12 07:07:06.000000000 -0600
@@ -6,46 +6,46 @@
 
 #ifndef llex_h
 #define llex_h
 
 #include "lobject.h"
 #include "lzio.h"
 
 
 #define FIRST_RESERVED	257
 
 /* maximum length of a reserved word */
 #define TOKEN_LEN	(sizeof("function")/sizeof(char))
 
 
 /*
 * WARNING: if you change the order of this enumeration,
 * grep "ORDER RESERVED"
 */
 enum RESERVED {
   /* terminal symbols denoted by reserved words */
-  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_AND = FIRST_RESERVED, TK_BREAK, TK_CATCH,
   TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
   TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
-  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_TRY, TK_UNTIL, TK_WHILE,
   /* other terminal symbols */
-  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
+  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LSHFT, TK_LE, TK_RSHFT, TK_XOR, TK_NE, TK_CNE, TK_NUMBER,
   TK_NAME, TK_STRING, TK_EOS
 };
 
 /* number of reserved words */
 #define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
 
 
 /* array with token `names' */
 LUAI_DATA const char *const luaX_tokens [];
 
 
 typedef union {
   lua_Number r;
   TString *ts;
 } SemInfo;  /* semantics information */
 
 
 typedef struct Token {
   int token;
   SemInfo seminfo;
diff -ruwN -U 20 lua-5.1.3-orig/src/lopcodes.c lua-5.1.3/src/lopcodes.c
--- lua-5.1.3-orig/src/lopcodes.c	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/lopcodes.c	2008-03-12 07:09:26.000000000 -0600
@@ -15,45 +15,55 @@
 
 const char *const luaP_opnames[NUM_OPCODES+1] = {
   "MOVE",
   "LOADK",
   "LOADBOOL",
   "LOADNIL",
   "GETUPVAL",
   "GETGLOBAL",
   "GETTABLE",
   "SETGLOBAL",
   "SETUPVAL",
   "SETTABLE",
   "NEWTABLE",
   "SELF",
   "ADD",
   "SUB",
   "MUL",
   "DIV",
   "MOD",
   "POW",
+  "BOR",
+  "BAND",
+  "OP_BXOR"
+  "BLSHFT",
+  "BRSHFT",
+  "BNOT",
+  "INTDIV",
   "UNM",
   "NOT",
   "LEN",
   "CONCAT",
   "JMP",
+  "TRY",
+  "ENDTRY",
+  "CATCH",
   "EQ",
   "LT",
   "LE",
   "TEST",
   "TESTSET",
   "CALL",
   "TAILCALL",
   "RETURN",
   "FORLOOP",
   "FORPREP",
   "TFORLOOP",
   "SETLIST",
   "CLOSE",
   "CLOSURE",
   "VARARG",
   NULL
 };
 
 
 #define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))
@@ -61,42 +71,52 @@
 const lu_byte luaP_opmodes[NUM_OPCODES] = {
 /*       T  A    B       C     mode		   opcode	*/
   opmode(0, 1, OpArgR, OpArgN, iABC) 		/* OP_MOVE */
  ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
  ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LOADNIL */
  ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
  ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_GETGLOBAL */
  ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
  ,opmode(0, 0, OpArgK, OpArgN, iABx)		/* OP_SETGLOBAL */
  ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
  ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
  ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
  ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BOR */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BAND */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BXOR */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BLSHFT */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_RLSHFT */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_BNOT */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_INTDIV */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
  ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
  ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
+ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_TRY */
+ ,opmode(0, 0, OpArgN, OpArgN, iABC)		/* OP_ENDTRY */
+ ,opmode(0, 1, OpArgN, OpArgN, iABC)		/* OP_CATCH */
  ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
  ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
  ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
  ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TEST */
  ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
  ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
  ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
  ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
  ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
  ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
  ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TFORLOOP */
  ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
  ,opmode(0, 0, OpArgN, OpArgN, iABC)		/* OP_CLOSE */
  ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
  ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
 };
 
diff -ruwN -U 20 lua-5.1.3-orig/src/lopcodes.h lua-5.1.3/src/lopcodes.h
--- lua-5.1.3-orig/src/lopcodes.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/lopcodes.h	2008-03-12 07:11:24.000000000 -0600
@@ -157,47 +157,57 @@
 OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
 OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
 
 OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
 OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
 
 OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
 OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
 OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
 
 OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
 
 OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
 
 OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
 OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
 OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
 OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
 OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
 OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_BOR,/*	A B C   R(A) := RK(B) | RK(C)				*/
+OP_BAND,/*	A B C   R(A) := RK(B) & RK(C)				*/
+OP_BXOR,/*	A B C   R(A) := RK(B) ^| RK(C)				*/
+OP_BLSHFT,/*A B C	R(A) := RK(B) << RK(C)				*/
+OP_BRSHFT,/*A B C	R(A) := RK(B) >> RK(C)				*/
+OP_BNOT,/*	A B		R(A) := ~ R(B)						*/
+OP_INTDIV,/*A B C	R(A) := RK(B) \ RK(C)				*/
 OP_UNM,/*	A B	R(A) := -R(B)					*/
 OP_NOT,/*	A B	R(A) := not R(B)				*/
 OP_LEN,/*	A B	R(A) := length of R(B)				*/
 
 OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
 
 OP_JMP,/*	sBx	pc+=sBx					*/
+OP_TRY,/* 	sBx	pc+=sBx					*/
+OP_ENDTRY,
+OP_CATCH, /* A  R(A)=errorobj */
 
 OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
 OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*/
 OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*/
 
 OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/ 
 OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/ 
 
 OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
 OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
 OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
 
 OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
 			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
 OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/
 
 OP_TFORLOOP,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
                         if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++	*/ 
 OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/
 
diff -ruwN -U 20 lua-5.1.3-orig/src/lparser.c lua-5.1.3/src/lparser.c
--- lua-5.1.3-orig/src/lparser.c	2007-12-28 08:32:23.000000000 -0700
+++ lua-5.1.3/src/lparser.c	2008-03-12 06:58:15.000000000 -0600
@@ -25,41 +25,41 @@
 #include "lstring.h"
 #include "ltable.h"
 
 
 
 #define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
 
 #define getlocvar(fs, i)	((fs)->f->locvars[(fs)->actvar[i]])
 
 #define luaY_checklimit(fs,v,l,m)	if ((v)>(l)) errorlimit(fs,l,m)
 
 
 /*
 ** nodes for block list (list of active blocks)
 */
 typedef struct BlockCnt {
   struct BlockCnt *previous;  /* chain */
   int breaklist;  /* list of jumps out of this loop */
   lu_byte nactvar;  /* # active locals outside the breakable structure */
   lu_byte upval;  /* true if some variable in the block is an upvalue */
-  lu_byte isbreakable;  /* true if `block' is a loop */
+  lu_byte isbreakable;  /* 0: normal block, 1: loop, 2: try-catch */
 } BlockCnt;
 
 
 
 /*
 ** prototypes for recursive non-terminal functions
 */
 static void chunk (LexState *ls);
 static void expr (LexState *ls, expdesc *v);
 
 
 static void anchor_token (LexState *ls) {
   if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
     TString *ts = ls->t.seminfo.ts;
     luaX_newstring(ls, getstr(ts), ts->tsv.len);
   }
 }
 
 
 static void error_expected (LexState *ls, int token) {
@@ -283,41 +283,41 @@
 
 
 static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
   bl->breaklist = NO_JUMP;
   bl->isbreakable = isbreakable;
   bl->nactvar = fs->nactvar;
   bl->upval = 0;
   bl->previous = fs->bl;
   fs->bl = bl;
   lua_assert(fs->freereg == fs->nactvar);
 }
 
 
 static void leaveblock (FuncState *fs) {
   BlockCnt *bl = fs->bl;
   fs->bl = bl->previous;
   removevars(fs->ls, bl->nactvar);
   if (bl->upval)
     luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
   /* a block either controls scope or breaks (never both) */
-  lua_assert(!bl->isbreakable || !bl->upval);
+  lua_assert(bl->isbreakable != 1|| !bl->upval);
   lua_assert(bl->nactvar == fs->nactvar);
   fs->freereg = fs->nactvar;  /* free registers */
   luaK_patchtohere(fs, bl->breaklist);
 }
 
 
 static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
   int oldsize = f->sizep;
   int i;
   luaM_growvector(ls->L, f->p, fs->np, f->sizep, Proto *,
                   MAXARG_Bx, "constant table overflow");
   while (oldsize < f->sizep) f->p[oldsize++] = NULL;
   f->p[fs->np++] = func->f;
   luaC_objbarrier(ls->L, f, func->f);
   init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np-1));
   for (i=0; i<func->f->nups; i++) {
     OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
     luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
@@ -763,72 +763,79 @@
     }
     case TK_FUNCTION: {
       luaX_next(ls);
       body(ls, v, 0, ls->linenumber);
       return;
     }
     default: {
       primaryexp(ls, v);
       return;
     }
   }
   luaX_next(ls);
 }
 
 
 static UnOpr getunopr (int op) {
   switch (op) {
     case TK_NOT: return OPR_NOT;
     case '-': return OPR_MINUS;
     case '#': return OPR_LEN;
+	case '~': return OPR_BNOT;
     default: return OPR_NOUNOPR;
   }
 }
 
 
 static BinOpr getbinopr (int op) {
   switch (op) {
     case '+': return OPR_ADD;
     case '-': return OPR_SUB;
     case '*': return OPR_MUL;
     case '/': return OPR_DIV;
     case '%': return OPR_MOD;
     case '^': return OPR_POW;
+    case '|': return OPR_BOR;
+    case '&': return OPR_BAND;
+    case TK_XOR: return OPR_BXOR;
+    case TK_LSHFT: return OPR_BLSHFT;
+    case TK_RSHFT: return OPR_BRSHFT;
+    case '\\': return OPR_INTDIV;
     case TK_CONCAT: return OPR_CONCAT;
     case TK_NE: return OPR_NE;
     case TK_EQ: return OPR_EQ;
     case '<': return OPR_LT;
     case TK_LE: return OPR_LE;
     case '>': return OPR_GT;
     case TK_GE: return OPR_GE;
     case TK_AND: return OPR_AND;
     case TK_OR: return OPR_OR;
     default: return OPR_NOBINOPR;
   }
 }
 
 
 static const struct {
   lu_byte left;  /* left priority for each binary operator */
   lu_byte right; /* right priority */
 } priority[] = {  /* ORDER OPR */
-   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `/' `%' */
+   {6, 6}, {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, /* `|' `&' `!' `<<' `>>' `\' */
    {10, 9}, {5, 4},                 /* power and concat (right associative) */
    {3, 3}, {3, 3},                  /* equality and inequality */
    {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
    {2, 2}, {1, 1}                   /* logical (and/or) */
 };
 
 #define UNARY_PRIORITY	8  /* priority for unary operators */
 
 
 /*
 ** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
 ** where `binop' is any binary operator with a priority higher than `limit'
 */
 static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
   BinOpr op;
   UnOpr uop;
   enterlevel(ls);
   uop = getunopr(ls->t.token);
   if (uop != OPR_NOUNOPR) {
     luaX_next(ls);
@@ -855,40 +862,41 @@
 
 static void expr (LexState *ls, expdesc *v) {
   subexpr(ls, v, 0);
 }
 
 /* }==================================================================== */
 
 
 
 /*
 ** {======================================================================
 ** Rules for Statements
 ** =======================================================================
 */
 
 
 static int block_follow (int token) {
   switch (token) {
     case TK_ELSE: case TK_ELSEIF: case TK_END:
     case TK_UNTIL: case TK_EOS:
+    case TK_CATCH:
       return 1;
     default: return 0;
   }
 }
 
 
 static void block (LexState *ls) {
   /* block -> chunk */
   FuncState *fs = ls->fs;
   BlockCnt bl;
   enterblock(fs, &bl, 0);
   chunk(ls);
   lua_assert(bl.breaklist == NO_JUMP);
   leaveblock(fs);
 }
 
 
 /*
 ** structure to chain all variables in the left-hand side of an
 ** assignment
@@ -959,41 +967,43 @@
   }
   init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
   luaK_storevar(ls->fs, &lh->v, &e);
 }
 
 
 static int cond (LexState *ls) {
   /* cond -> exp */
   expdesc v;
   expr(ls, &v);  /* read condition */
   if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
   luaK_goiftrue(ls->fs, &v);
   return v.f;
 }
 
 
 static void breakstat (LexState *ls) {
   FuncState *fs = ls->fs;
   BlockCnt *bl = fs->bl;
   int upval = 0;
-  while (bl && !bl->isbreakable) {
+  while (bl && bl->isbreakable != 1) {
+    if (bl->isbreakable == 2)
+      luaK_codeABC(fs, OP_ENDTRY, 0, 0, 0);
     upval |= bl->upval;
     bl = bl->previous;
   }
   if (!bl)
     luaX_syntaxerror(ls, "no loop to break");
   if (upval)
     luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
   luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
 }
 
 
 static void whilestat (LexState *ls, int line) {
   /* whilestat -> WHILE cond DO block END */
   FuncState *fs = ls->fs;
   int whileinit;
   int condexit;
   BlockCnt bl;
   luaX_next(ls);  /* skip WHILE */
   whileinit = luaK_getlabel(fs);
   condexit = cond(ls);
@@ -1145,40 +1155,93 @@
   int escapelist = NO_JUMP;
   flist = test_then_block(ls);  /* IF cond THEN block */
   while (ls->t.token == TK_ELSEIF) {
     luaK_concat(fs, &escapelist, luaK_jump(fs));
     luaK_patchtohere(fs, flist);
     flist = test_then_block(ls);  /* ELSEIF cond THEN block */
   }
   if (ls->t.token == TK_ELSE) {
     luaK_concat(fs, &escapelist, luaK_jump(fs));
     luaK_patchtohere(fs, flist);
     luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
     block(ls);  /* `else' part */
   }
   else
     luaK_concat(fs, &escapelist, flist);
   luaK_patchtohere(fs, escapelist);
   check_match(ls, TK_END, TK_IF, line);
 }
 
 
+static void trystat (LexState *ls, int line) {
+  /* trystat -> TRY block CATCH err DO block END */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  int escapelist = NO_JUMP;
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int pc;
+
+  fs->jpc = NO_JUMP;
+  luaX_next(ls);
+  pc = luaK_codeAsBx(fs, OP_TRY, 0, NO_JUMP);
+  luaK_concat(fs, &pc, jpc);  /* keep them on hold */
+
+  enterblock(fs, &bl, 2);   /* try-catch block */
+  block(ls);
+  leaveblock(fs);
+
+  if (ls->t.token == TK_CATCH) {
+    TString *varname;
+    int base;
+
+    luaK_codeABC(fs, OP_ENDTRY, 0, 0, 0);
+    luaK_concat(fs, &escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, pc);
+
+    // local err
+    enterblock(fs, &bl, 0);
+    luaX_next(ls);  /* skip `catch' */
+    varname = str_checkname(ls);  /* first variable name */
+
+    // do
+    checknext(ls, TK_DO);
+    base = fs->freereg;
+    new_localvar(ls, varname, 0);
+    adjustlocalvars(ls, 1);  /* control variables */
+    luaK_reserveregs(fs, 1);
+
+    luaK_codeABC(fs, OP_CATCH, base, 0, 0);  /* OP_CATCH sets error object to local 'varname'*/
+
+    block(ls);
+    leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+  }
+  else {
+    luaK_codeABC(fs, OP_ENDTRY, 0, 0, 0);
+    luaK_concat(fs, &escapelist, pc);
+  }
+
+  luaK_patchtohere(fs, escapelist);
+
+  check_match(ls, TK_END, TK_TRY, line);
+}
+
+
 static void localfunc (LexState *ls) {
   expdesc v, b;
   FuncState *fs = ls->fs;
   new_localvar(ls, str_checkname(ls), 0);
   init_exp(&v, VLOCAL, fs->freereg);
   luaK_reserveregs(fs, 1);
   adjustlocalvars(ls, 1);
   body(ls, &b, 0, ls->linenumber);
   luaK_storevar(fs, &v, &b);
   /* debug information will only see the variable after this point! */
   getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;
 }
 
 
 static void localstat (LexState *ls) {
   /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
   int nvars = 0;
   int nexps;
   expdesc e;
   do {
@@ -1221,99 +1284,111 @@
 }
 
 
 static void exprstat (LexState *ls) {
   /* stat -> func | assignment */
   FuncState *fs = ls->fs;
   struct LHS_assign v;
   primaryexp(ls, &v.v);
   if (v.v.k == VCALL)  /* stat -> func */
     SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */
   else {  /* stat -> assignment */
     v.prev = NULL;
     assignment(ls, &v, 1);
   }
 }
 
 
 static void retstat (LexState *ls) {
   /* stat -> RETURN explist */
   FuncState *fs = ls->fs;
+  BlockCnt *bl = fs->bl;
   expdesc e;
   int first, nret;  /* registers with returned values */
   luaX_next(ls);  /* skip RETURN */
   if (block_follow(ls->t.token) || ls->t.token == ';')
     first = nret = 0;  /* return no values */
   else {
     nret = explist1(ls, &e);  /* optional return values */
     if (hasmultret(e.k)) {
       luaK_setmultret(fs, &e);
       if (e.k == VCALL && nret == 1) {  /* tail call? */
         SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
         lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
       }
       first = fs->nactvar;
       nret = LUA_MULTRET;  /* return all values */
     }
     else {
       if (nret == 1)  /* only one single value? */
         first = luaK_exp2anyreg(fs, &e);
       else {
         luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
         first = fs->nactvar;  /* return all `active' values */
         lua_assert(nret == fs->freereg - first);
       }
     }
   }
+
+  /* before return, we should exit all try-catch blocks */
+  while (bl) {
+    if (bl->isbreakable == 2)
+      luaK_codeABC(fs, OP_ENDTRY, 0, 0, 0);
+    bl = bl->previous;
+  }
   luaK_ret(fs, first, nret);
 }
 
 
 static int statement (LexState *ls) {
   int line = ls->linenumber;  /* may be needed for error messages */
   switch (ls->t.token) {
     case TK_IF: {  /* stat -> ifstat */
       ifstat(ls, line);
       return 0;
     }
     case TK_WHILE: {  /* stat -> whilestat */
       whilestat(ls, line);
       return 0;
     }
     case TK_DO: {  /* stat -> DO block END */
       luaX_next(ls);  /* skip DO */
       block(ls);
       check_match(ls, TK_END, TK_DO, line);
       return 0;
     }
     case TK_FOR: {  /* stat -> forstat */
       forstat(ls, line);
       return 0;
     }
     case TK_REPEAT: {  /* stat -> repeatstat */
       repeatstat(ls, line);
       return 0;
     }
     case TK_FUNCTION: {
       funcstat(ls, line);  /* stat -> funcstat */
       return 0;
     }
+    case TK_TRY: {
+      trystat(ls, line);
+      return 0;
+    }
     case TK_LOCAL: {  /* stat -> localstat */
       luaX_next(ls);  /* skip LOCAL */
       if (testnext(ls, TK_FUNCTION))  /* local function? */
         localfunc(ls);
       else
         localstat(ls);
       return 0;
     }
     case TK_RETURN: {  /* stat -> retstat */
       retstat(ls);
       return 1;  /* must be last statement */
     }
     case TK_BREAK: {  /* stat -> breakstat */
       luaX_next(ls);  /* skip BREAK */
       breakstat(ls);
       return 1;  /* must be last statement */
     }
     default: {
       exprstat(ls);
       return 0;  /* to avoid warnings */
diff -ruwN -U 20 lua-5.1.3-orig/src/lstate.c lua-5.1.3/src/lstate.c
--- lua-5.1.3-orig/src/lstate.c	2008-01-03 08:20:39.000000000 -0700
+++ lua-5.1.3/src/lstate.c	2008-03-12 06:57:21.000000000 -0600
@@ -42,42 +42,60 @@
 static void stack_init (lua_State *L1, lua_State *L) {
   /* initialize CallInfo array */
   L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
   L1->ci = L1->base_ci;
   L1->size_ci = BASIC_CI_SIZE;
   L1->end_ci = L1->base_ci + L1->size_ci - 1;
   /* initialize stack array */
   L1->stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);
   L1->stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
   L1->top = L1->stack;
   L1->stack_last = L1->stack+(L1->stacksize - EXTRA_STACK)-1;
   /* initialize first ci */
   L1->ci->func = L1->top;
   setnilvalue(L1->top++);  /* `function' entry for this `ci' */
   L1->base = L1->ci->base = L1->top;
   L1->ci->top = L1->top + LUA_MINSTACK;
 }
 
 
 static void freestack (lua_State *L, lua_State *L1) {
+  struct lua_longjmp *pj, *pprev, *pnext;
   luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
   luaM_freearray(L, L1->stack, L1->stacksize, TValue);
+
+  /* free try-catch info */
+  pj = L->errorJmp;
+  pnext = NULL;
+  while (pj) {
+    pprev = pj->previous;
+    if (pj->type == JMPTYPE_TRY) {
+      if (pnext == NULL)
+        L->errorJmp = pprev;
+      else
+        pnext->previous = pprev;
+      luaM_free(L, pj);
+    }
+    else
+      pnext = pj;
+    pj = pprev;
+  }
 }
 
 
 /*
 ** open parts that may cause memory-allocation errors
 */
 static void f_luaopen (lua_State *L, void *ud) {
   global_State *g = G(L);
   UNUSED(ud);
   stack_init(L, L);  /* init stack */
   sethvalue(L, gt(L), luaH_new(L, 0, 2));  /* table of globals */
   sethvalue(L, registry(L), luaH_new(L, 0, 2));  /* registry */
   luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
   luaT_init(L);
   luaX_init(L);
   luaS_fix(luaS_newliteral(L, MEMERRMSG));
   g->GCthreshold = 4*g->totalbytes;
 }
 
 
diff -ruwN -U 20 lua-5.1.3-orig/src/ltm.c lua-5.1.3/src/ltm.c
--- lua-5.1.3-orig/src/ltm.c	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/ltm.c	2008-03-12 06:58:15.000000000 -0600
@@ -16,41 +16,42 @@
 #include "lstate.h"
 #include "lstring.h"
 #include "ltable.h"
 #include "ltm.h"
 
 
 
 const char *const luaT_typenames[] = {
   "nil", "boolean", "userdata", "number",
   "string", "table", "function", "userdata", "thread",
   "proto", "upval"
 };
 
 
 void luaT_init (lua_State *L) {
   static const char *const luaT_eventname[] = {  /* ORDER TM */
     "__index", "__newindex",
     "__gc", "__mode", "__eq",
     "__add", "__sub", "__mul", "__div", "__mod",
     "__pow", "__unm", "__len", "__lt", "__le",
-    "__concat", "__call"
+    "__concat", "__call",
+    "__or", "__and", "__xor", "__shl", "__shr", "__not", "__intdiv"
   };
   int i;
   for (i=0; i<TM_N; i++) {
     G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
     luaS_fix(G(L)->tmname[i]);  /* never collect these names */
   }
 }
 
 
 /*
 ** function to be used with macro "fasttm": optimized for absence of
 ** tag methods
 */
 const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
   const TValue *tm = luaH_getstr(events, ename);
   lua_assert(event <= TM_EQ);
   if (ttisnil(tm)) {  /* no tag method? */
     events->flags |= cast_byte(1u<<event);  /* cache this fact */
     return NULL;
   }
diff -ruwN -U 20 lua-5.1.3-orig/src/ltm.h lua-5.1.3/src/ltm.h
--- lua-5.1.3-orig/src/ltm.h	2007-12-27 06:02:25.000000000 -0700
+++ lua-5.1.3/src/ltm.h	2008-03-12 06:58:15.000000000 -0600
@@ -16,39 +16,46 @@
 * grep "ORDER TM"
 */
 typedef enum {
   TM_INDEX,
   TM_NEWINDEX,
   TM_GC,
   TM_MODE,
   TM_EQ,  /* last tag method with `fast' access */
   TM_ADD,
   TM_SUB,
   TM_MUL,
   TM_DIV,
   TM_MOD,
   TM_POW,
   TM_UNM,
   TM_LEN,
   TM_LT,
   TM_LE,
   TM_CONCAT,
   TM_CALL,
+  TM_BOR,
+  TM_BAND,
+  TM_BXOR,
+  TM_BRSHFT,
+  TM_BLSHFT,
+  TM_BNOT,
+  TM_INTDIV,
   TM_N		/* number of elements in the enum */
 } TMS;
 
 
 
 #define gfasttm(g,et,e) ((et) == NULL ? NULL : \
   ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
 
 #define fasttm(l,et,e)	gfasttm(G(l), et, e)
 
 LUAI_DATA const char *const luaT_typenames[];
 
 
 LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
 LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
                                                        TMS event);
 LUAI_FUNC void luaT_init (lua_State *L);
 
 #endif
diff -ruwN -U 20 lua-5.1.3-orig/src/luaconf.h lua-5.1.3/src/luaconf.h
--- lua-5.1.3-orig/src/luaconf.h	2008-01-18 10:07:48.000000000 -0700
+++ lua-5.1.3/src/luaconf.h	2008-03-12 06:58:15.000000000 -0600
@@ -517,47 +517,54 @@
 @@ lua_number2str converts a number to a string.
 @@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
 @@ lua_str2number converts a string to a number.
 */
 #define LUA_NUMBER_SCAN		"%lf"
 #define LUA_NUMBER_FMT		"%.14g"
 #define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
 #define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
 #define lua_str2number(s,p)	strtod((s), (p))
 
 
 /*
 @@ The luai_num* macros define the primitive operations over numbers.
 */
 #if defined(LUA_CORE)
 #include <math.h>
 #define luai_numadd(a,b)	((a)+(b))
 #define luai_numsub(a,b)	((a)-(b))
 #define luai_nummul(a,b)	((a)*(b))
 #define luai_numdiv(a,b)	((a)/(b))
+#define luai_numintdiv(a,b)	(floor((a)/(b)))
 #define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
 #define luai_numpow(a,b)	(pow(a,b))
 #define luai_numunm(a)		(-(a))
 #define luai_numeq(a,b)		((a)==(b))
 #define luai_numlt(a,b)		((a)<(b))
 #define luai_numle(a,b)		((a)<=(b))
 #define luai_numisnan(a)	(!luai_numeq((a), (a)))
+#define luai_logor(r, a, b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai|bi; }
+#define luai_logand(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai&bi; }
+#define luai_logxor(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai^bi; }
+#define luai_lognot(r,a)	{ lua_Integer ai; lua_number2int(ai,a); r = ~ai; }
+#define luai_logrshft(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai>>bi; }
+#define luai_loglshft(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai<<bi; }
 #endif
 
 
 /*
 @@ lua_number2int is a macro to convert lua_Number to int.
 @@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
 ** CHANGE them if you know a faster way to convert a lua_Number to
 ** int (with any rounding method and without throwing errors) in your
 ** system. In Pentium machines, a naive typecast from double to int
 ** in C is extremely slow, so any alternative is worth trying.
 */
 
 /* On a Pentium, resort to a trick */
 #if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
     (defined(__i386) || defined (_M_IX86) || defined(__i386__))
 
 /* On a Microsoft compiler, use assembler */
 #if defined(_MSC_VER)
 
 #define lua_number2int(i,d)   __asm fld d   __asm fistp i
@@ -586,48 +593,41 @@
 
 
 /*
 @@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
 ** CHANGE it if your system requires alignments larger than double. (For
 ** instance, if your system supports long doubles and they must be
 ** aligned in 16-byte boundaries, then you should add long double in the
 ** union.) Probably you do not need to change this.
 */
 #define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
 
 
 /*
 @@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
 ** CHANGE them if you prefer to use longjmp/setjmp even with C++
 ** or if want/don't to use _longjmp/_setjmp instead of regular
 ** longjmp/setjmp. By default, Lua handles errors with exceptions when
 ** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
 ** and with longjmp/setjmp otherwise.
 */
-#if defined(__cplusplus)
-/* C++ exceptions */
-#define LUAI_THROW(L,c)	throw(c)
-#define LUAI_TRY(L,c,a)	try { a } catch(...) \
-	{ if ((c)->status == 0) (c)->status = -1; }
-#define luai_jmpbuf	int  /* dummy variable */
-
-#elif defined(LUA_USE_ULONGJMP)
+#if defined(LUA_USE_ULONGJMP)
 /* in Unix, try _longjmp/_setjmp (more efficient) */
 #define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
 #define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
 #define luai_jmpbuf	jmp_buf
 
 #else
 /* default handling with long jumps */
 #define LUAI_THROW(L,c)	longjmp((c)->b, 1)
 #define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
 #define luai_jmpbuf	jmp_buf
 
 #endif
 
 
 /*
 @@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
 @* can do during pattern-matching.
 ** CHANGE it if you need more captures. This limit is arbitrary.
 */
 #define LUA_MAXCAPTURES		32
diff -ruwN -U 20 lua-5.1.3-orig/src/lvm.c lua-5.1.3/src/lvm.c
--- lua-5.1.3-orig/src/lvm.c	2007-12-28 08:32:23.000000000 -0700
+++ lua-5.1.3/src/lvm.c	2008-03-12 07:02:42.000000000 -0600
@@ -308,90 +308,158 @@
     last -= n-1;
   } while (total > 1);  /* repeat until only 1 result left */
 }
 
 
 static void Arith (lua_State *L, StkId ra, const TValue *rb,
                    const TValue *rc, TMS op) {
   TValue tempb, tempc;
   const TValue *b, *c;
   if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
       (c = luaV_tonumber(rc, &tempc)) != NULL) {
     lua_Number nb = nvalue(b), nc = nvalue(c);
     switch (op) {
       case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
       case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
       case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
       case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
       case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
       case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
       case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
+      case TM_INTDIV: setnvalue(ra, luai_numintdiv(nb, nc)); break;
       default: lua_assert(0); break;
     }
   }
   else if (!call_binTM(L, rb, rc, ra, op))
     luaG_aritherror(L, rb, rc);
 }
 
 
+static void Logic (lua_State *L, StkId ra, const TValue *rb,
+                   const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    lua_Number nb = nvalue(b), nc = nvalue(c);
+    lua_Integer r;
+    switch (op) {
+      case TM_BLSHFT: luai_loglshft(r, nb, nc); break;
+      case TM_BRSHFT: luai_logrshft(r, nb, nc); break;
+      case TM_BOR: luai_logor(r, nb, nc); break;
+      case TM_BAND: luai_logand(r, nb, nc); break;
+      case TM_BXOR: luai_logxor(r, nb, nc); break;
+      case TM_BNOT: luai_lognot(r, nb); break;
+      default: lua_assert(0); r = 0; break;
+    }
+    setnvalue(ra, r);
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_logicerror(L, rb, rc);
+}
+
 
 /*
 ** some macros for common tasks in `luaV_execute'
 */
 
 #define runtime_check(L, c)	{ if (!(c)) break; }
 
 #define RA(i)	(base+GETARG_A(i))
 /* to be used after possible stack reallocation */
 #define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
 #define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
 #define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
 	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
 #define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
 	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
 #define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))
 
 
 #define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}
 
 
 #define Protect(x)	{ L->savedpc = pc; {x;}; base = L->base; }
 
 
 #define arith_op(op,tm) { \
         TValue *rb = RKB(i); \
         TValue *rc = RKC(i); \
         if (ttisnumber(rb) && ttisnumber(rc)) { \
           lua_Number nb = nvalue(rb), nc = nvalue(rc); \
           setnvalue(ra, op(nb, nc)); \
         } \
         else \
           Protect(Arith(L, ra, rb, rc, tm)); \
       }
 
+#define logic_op(op,tm) { \
+        TValue *rb = RKB(i); \
+        TValue *rc = RKC(i); \
+        if (ttisnumber(rb) && ttisnumber(rc)) { \
+          lua_Integer r; \
+          op(r, nvalue(rb), nvalue(rc)); \
+          setnvalue(ra, r); \
+        } \
+        else \
+          Protect(Logic(L, ra, rb, rc, tm)); \
+      }
+
+static void releasetry(lua_State *L) {
+  struct lua_longjmp *pj = L->errorJmp;
+  if (pj->type == JMPTYPE_TRY) {
+    L->errfunc = pj->old_errfunc;
+    L->errorJmp = pj->previous;
+    luaM_free(L, pj);
+  }
+}
+
+static void restoretry(lua_State *L, int seterr, int ra) {
+  struct lua_longjmp *pj = L->errorJmp;
 
+  StkId oldtop = restorestack(L, pj->old_top);
+  luaF_close(L, oldtop);  /* close eventual pending closures */
+
+  L->nCcalls = pj->oldnCcalls;
+  L->ci = restoreci(L, pj->old_ci);
+  L->base = L->ci->base;
+  L->allowhook = pj->old_allowhooks;
+
+  if (seterr)
+    luaD_seterrorobj(L, pj->status, L->base + ra);
+  L->top = oldtop;
+
+  if (L->size_ci > LUAI_MAXCALLS) {  /* there was an overflow? */
+    int inuse = cast_int(L->ci - L->base_ci);
+    if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */
+      luaD_reallocCI(L, LUAI_MAXCALLS);
+  }
+  releasetry(L);
+}
 
 void luaV_execute (lua_State *L, int nexeccalls) {
   LClosure *cl;
   StkId base;
   TValue *k;
   const Instruction *pc;
+  struct lua_longjmp *pj;
+
  reentry:  /* entry point */
   lua_assert(isLua(L->ci));
   pc = L->savedpc;
   cl = &clvalue(L->ci->func)->l;
   base = L->base;
   k = cl->p->k;
   /* main loop of interpreter */
   for (;;) {
     const Instruction i = *pc++;
     StkId ra;
     if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
         (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
       traceexec(L, pc);
       if (L->status == LUA_YIELD) {  /* did hook yield? */
         L->savedpc = pc - 1;
         return;
       }
       base = L->base;
     }
     /* warning!! several calls may realloc the stack and invalidate `ra' */
@@ -485,40 +553,76 @@
       }
       case OP_MOD: {
         arith_op(luai_nummod, TM_MOD);
         continue;
       }
       case OP_POW: {
         arith_op(luai_numpow, TM_POW);
         continue;
       }
       case OP_UNM: {
         TValue *rb = RB(i);
         if (ttisnumber(rb)) {
           lua_Number nb = nvalue(rb);
           setnvalue(ra, luai_numunm(nb));
         }
         else {
           Protect(Arith(L, ra, rb, rb, TM_UNM));
         }
         continue;
       }
+      case OP_BOR: {
+        logic_op(luai_logor, TM_BOR);
+        continue;
+      }
+      case OP_BAND: {
+        logic_op(luai_logand, TM_BAND);
+        continue;
+      }
+      case OP_BXOR: {
+        logic_op(luai_logxor, TM_BXOR);
+        continue;
+      }
+      case OP_BLSHFT: {
+        logic_op(luai_loglshft, TM_BRSHFT);
+        continue;
+      }
+      case OP_BRSHFT: {
+        logic_op(luai_logrshft, TM_BRSHFT);
+        continue;
+      }
+      case OP_BNOT: {
+        TValue *rb = RB(i);
+        if (ttisnumber(rb)) {
+          lua_Integer r;
+          luai_lognot(r, nvalue(rb));
+          setnvalue(ra, r);
+        }
+        else {
+          Protect(Logic(L, ra, rb, rb, TM_BNOT));
+        }
+        continue;
+      }
+      case OP_INTDIV: {
+        arith_op(luai_numintdiv, TM_DIV);
+        continue;
+      }
       case OP_NOT: {
         int res = l_isfalse(RB(i));  /* next assignment may change this value */
         setbvalue(ra, res);
         continue;
       }
       case OP_LEN: {
         const TValue *rb = RB(i);
         switch (ttype(rb)) {
           case LUA_TTABLE: {
             setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
             break;
           }
           case LUA_TSTRING: {
             setnvalue(ra, cast_num(tsvalue(rb)->len));
             break;
           }
           default: {  /* try metamethod */
             Protect(
               if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
                 luaG_typeerror(L, rb, "get length of");
@@ -740,24 +844,60 @@
         int b = GETARG_B(i) - 1;
         int j;
         CallInfo *ci = L->ci;
         int n = cast_int(ci->base - ci->func) - cl->p->numparams - 1;
         if (b == LUA_MULTRET) {
           Protect(luaD_checkstack(L, n));
           ra = RA(i);  /* previous call may change the stack */
           b = n;
           L->top = ra + n;
         }
         for (j = 0; j < b; j++) {
           if (j < n) {
             setobjs2s(L, ra + j, ci->base - n + j);
           }
           else {
             setnilvalue(ra + j);
           }
         }
         continue;
       }
+      case OP_TRY: {
+          int status;
+          pj = luaM_malloc(L, sizeof(struct lua_longjmp));
+          pj->type = JMPTYPE_TRY;
+          pj->status = 0;
+          pj->pc = pc + GETARG_sBx(i);
+          pj->previous = L->errorJmp;
+
+          pj->oldnCcalls = L->nCcalls;
+          pj->old_ci = saveci(L, L->ci);
+          pj->old_allowhooks = L->allowhook;
+          pj->old_errfunc = L->errfunc;
+          pj->old_nexeccalls = nexeccalls;
+          pj->old_top = savestack(L, L->top);
+          L->errorJmp = pj;
+          L->errfunc = 0;
+
+          status = setjmp(pj->b);
+          if (status) {
+            pc = L->errorJmp->pc;
+            nexeccalls = L->errorJmp->old_nexeccalls;
+            restoretry(L, GET_OPCODE(*pc) == OP_CATCH, GETARG_A(*pc));
+            L->savedpc = pc;
+            goto reentry;
+          }
+
+        continue;
+      }
+      case OP_ENDTRY: {
+        releasetry(L);
+        continue;
+      }
+      case OP_CATCH: {
+        // dummy opcode, do nothing here!
+        continue;
+      }
     }
   }
 }
 
diff -ruwN -U 20 lua-5.1.3-orig/test/bitwise.lua lua-5.1.3/test/bitwise.lua
--- lua-5.1.3-orig/test/bitwise.lua	1969-12-31 17:00:00.000000000 -0700
+++ lua-5.1.3/test/bitwise.lua	2008-03-12 07:30:48.000000000 -0600
@@ -0,0 +1,31 @@
+hex=function (i) return "0x"..string.format("%X", i) end
+
+--[[
+a = 0x54|0x55
+print(hex(a))
+print(hex(0x54|0x55))
+print(hex(0x54&0x66))
+print(hex(0x54^|0x66))
+print(hex(~0x54))
+print(hex(0xF<< 4))
+print(hex(0xF0>> 4))
+a,b=0x54,0x55
+print(hex(a),"|",hex(b), "=",hex(a|b))
+print(hex(a),"|","0x55", "=",hex(a|0x55))
+print(hex(a),"|","0x5|0x50 (", hex(0x5|0x50), ") =",hex(a|(0x5|0x50)))
+a,b=0x54,0x66
+print(hex(a),"&",hex(b), "=",hex(a&b))
+print(hex(a),"&","0x66", "=",hex(a&0x66))
+print(hex(a),"^|",hex(b), "=",hex(a^|b))
+print(hex(a),"^|","0x66", "=",hex(a^|0x66))
+print("~"..hex(a),"=",hex(~a))
+]]--
+
+
+a,b=0xF,0xF0
+print(hex(a).."<<4","=",hex(a<<4))
+print(hex(b)..">>4","=",hex(b>>4))
+a,b=0xF,4
+print(hex(a).."<<"..b,"=",hex(a<<b))
+a,b=0xF0,4
+print(hex(a)..">>"..b,"=",hex(a>>b))
