diff -rw -C 10 lua-5.1.3-orig/src/lcode.c lua-5.1.3/src/lcode.c
*** lua-5.1.3-orig/src/lcode.c	2007-12-28 08:32:23.000000000 -0700
--- lua-5.1.3/src/lcode.c	2008-03-12 06:24:05.000000000 -0600
***************
*** 643,675 ****
      case OP_MUL: r = luai_nummul(v1, v2); break;
      case OP_DIV:
        if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
        r = luai_numdiv(v1, v2); break;
      case OP_MOD:
        if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
        r = luai_nummod(v1, v2); break;
      case OP_POW: r = luai_numpow(v1, v2); break;
      case OP_UNM: r = luai_numunm(v1); break;
      case OP_LEN: return 0;  /* no constant folding for 'len' */
      default: lua_assert(0); r = 0; break;
    }
    if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
    e1->u.nval = r;
    return 1;
  }
  
  
  static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
    if (constfolding(op, e1, e2))
      return;
    else {
!     int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
      int o1 = luaK_exp2RK(fs, e1);
      if (o1 > o2) {
        freeexp(fs, e1);
        freeexp(fs, e2);
      }
      else {
        freeexp(fs, e2);
        freeexp(fs, e1);
      }
      e1->u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
--- 643,684 ----
      case OP_MUL: r = luai_nummul(v1, v2); break;
      case OP_DIV:
        if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
        r = luai_numdiv(v1, v2); break;
      case OP_MOD:
        if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
        r = luai_nummod(v1, v2); break;
      case OP_POW: r = luai_numpow(v1, v2); break;
      case OP_UNM: r = luai_numunm(v1); break;
      case OP_LEN: return 0;  /* no constant folding for 'len' */
+     case OP_BOR: luai_logor(r, v1, v2); break;
+     case OP_BAND: luai_logand(r, v1, v2); break;
+     case OP_BXOR: luai_logxor(r, v1, v2);  break;
+     case OP_BRSHFT: luai_logrshft(r, v1, v2); break;
+     case OP_BLSHFT: luai_loglshft(r, v1, v2); break;
+     case OP_BNOT: luai_lognot(r, v1); break;
+     case OP_INTDIV:
+       if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+       r = luai_numintdiv(v1, v2); break;
      default: lua_assert(0); r = 0; break;
    }
    if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
    e1->u.nval = r;
    return 1;
  }
  
  
  static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
    if (constfolding(op, e1, e2))
      return;
    else {
! 	int o2 = (op != OP_UNM && op != OP_LEN && op != OP_BNOT) ? luaK_exp2RK(fs, e2) : 0;
      int o1 = luaK_exp2RK(fs, e1);
      if (o1 > o2) {
        freeexp(fs, e1);
        freeexp(fs, e2);
      }
      else {
        freeexp(fs, e2);
        freeexp(fs, e1);
      }
      e1->u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
***************
*** 691,710 ****
--- 700,725 ----
    }
    e1->u.s.info = condjump(fs, op, cond, o1, o2);
    e1->k = VJMP;
  }
  
  
  void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
    expdesc e2;
    e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
    switch (op) {
+     case OPR_BNOT: {
+       if (e->k == VK)
+         luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
+       codearith(fs, OP_BNOT, e, &e2);
+       break;
+     }
      case OPR_MINUS: {
        if (!isnumeral(e))
          luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
        codearith(fs, OP_UNM, e, &e2);
        break;
      }
      case OPR_NOT: codenot(fs, e); break;
      case OPR_LEN: {
        luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
        codearith(fs, OP_LEN, e, &e2);
***************
*** 777,796 ****
--- 792,817 ----
      case OPR_MUL: codearith(fs, OP_MUL, e1, e2); break;
      case OPR_DIV: codearith(fs, OP_DIV, e1, e2); break;
      case OPR_MOD: codearith(fs, OP_MOD, e1, e2); break;
      case OPR_POW: codearith(fs, OP_POW, e1, e2); break;
      case OPR_EQ: codecomp(fs, OP_EQ, 1, e1, e2); break;
      case OPR_NE: codecomp(fs, OP_EQ, 0, e1, e2); break;
      case OPR_LT: codecomp(fs, OP_LT, 1, e1, e2); break;
      case OPR_LE: codecomp(fs, OP_LE, 1, e1, e2); break;
      case OPR_GT: codecomp(fs, OP_LT, 0, e1, e2); break;
      case OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); break;
+     case OPR_BOR: codearith(fs, OP_BOR, e1, e2); break;
+     case OPR_BAND: codearith(fs, OP_BAND, e1, e2); break;
+     case OPR_BXOR: codearith(fs, OP_BXOR, e1, e2); break;
+     case OPR_BLSHFT: codearith(fs, OP_BLSHFT, e1, e2); break;
+     case OPR_BRSHFT: codearith(fs, OP_BRSHFT, e1, e2); break;
+     case OPR_INTDIV: codearith(fs, OP_INTDIV, e1, e2); break;
      default: lua_assert(0);
    }
  }
  
  
  void luaK_fixline (FuncState *fs, int line) {
    fs->f->lineinfo[fs->pc - 1] = line;
  }
  
  
diff -rw -C 10 lua-5.1.3-orig/src/lcode.h lua-5.1.3/src/lcode.h
*** lua-5.1.3-orig/src/lcode.h	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/lcode.h	2008-03-12 06:25:15.000000000 -0600
***************
*** 18,47 ****
  ** address, and as a list link (would link an element to itself).
  */
  #define NO_JUMP (-1)
  
  
  /*
  ** grep "ORDER OPR" if you change these enums
  */
  typedef enum BinOpr {
    OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
    OPR_CONCAT,
    OPR_NE, OPR_EQ,
    OPR_LT, OPR_LE, OPR_GT, OPR_GE,
    OPR_AND, OPR_OR,
    OPR_NOBINOPR
  } BinOpr;
  
  
! typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
! 
  
  #define getcode(fs,e)	((fs)->f->code[(e)->u.s.info])
  
  #define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
  
  #define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
  
  LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
  LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
  LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
--- 18,47 ----
  ** address, and as a list link (would link an element to itself).
  */
  #define NO_JUMP (-1)
  
  
  /*
  ** grep "ORDER OPR" if you change these enums
  */
  typedef enum BinOpr {
    OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+   OPR_BOR, OPR_BAND, OPR_BXOR, OPR_BLSHFT, OPR_BRSHFT, OPR_INTDIV,
    OPR_CONCAT,
    OPR_NE, OPR_EQ,
    OPR_LT, OPR_LE, OPR_GT, OPR_GE,
    OPR_AND, OPR_OR,
    OPR_NOBINOPR
  } BinOpr;
  
  
! typedef enum UnOpr { OPR_BNOT, OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
  
  #define getcode(fs,e)	((fs)->f->code[(e)->u.s.info])
  
  #define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
  
  #define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
  
  LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
  LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
  LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
diff -rw -C 10 lua-5.1.3-orig/src/ldebug.c lua-5.1.3/src/ldebug.c
*** lua-5.1.3-orig/src/ldebug.c	2007-12-28 08:32:23.000000000 -0700
--- lua-5.1.3/src/ldebug.c	2008-03-12 06:26:14.000000000 -0600
***************
*** 569,588 ****
--- 569,594 ----
  }
  
  
  void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
    TValue temp;
    if (luaV_tonumber(p1, &temp) == NULL)
      p2 = p1;  /* first operand is wrong */
    luaG_typeerror(L, p2, "perform arithmetic on");
  }
  
+ void luaG_logicerror (lua_State *L, const TValue *p1, const TValue *p2) {
+   TValue temp;
+   if (luaV_tonumber(p1, &temp) == NULL)
+     p2 = p1;  /* first operand is wrong */
+   luaG_typeerror(L, p2, "perform bitwise operation on");
+ }
  
  int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
    const char *t1 = luaT_typenames[ttype(p1)];
    const char *t2 = luaT_typenames[ttype(p2)];
    if (t1[2] == t2[2])
      luaG_runerror(L, "attempt to compare two %s values", t1);
    else
      luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
    return 0;
  }
diff -rw -C 10 lua-5.1.3-orig/src/ldebug.h lua-5.1.3/src/ldebug.h
*** lua-5.1.3-orig/src/ldebug.h	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/ldebug.h	2008-03-12 06:27:12.000000000 -0600
***************
*** 22,33 ****
--- 22,35 ----
                                               const char *opname);
  LUAI_FUNC void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
  LUAI_FUNC void luaG_aritherror (lua_State *L, const TValue *p1,
                                                const TValue *p2);
  LUAI_FUNC int luaG_ordererror (lua_State *L, const TValue *p1,
                                               const TValue *p2);
  LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);
  LUAI_FUNC void luaG_errormsg (lua_State *L);
  LUAI_FUNC int luaG_checkcode (const Proto *pt);
  LUAI_FUNC int luaG_checkopenop (Instruction i);
+ LUAI_FUNC void luaG_logicerror (lua_State *L, const TValue *p1,
+                                               const TValue *p2);
  
  #endif
diff -rw -C 10 lua-5.1.3-orig/src/llex.c lua-5.1.3/src/llex.c
*** lua-5.1.3-orig/src/llex.c	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/llex.c	2008-03-12 06:32:33.000000000 -0600
***************
*** 32,52 ****
  
  #define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
  
  
  /* ORDER RESERVED */
  const char *const luaX_tokens [] = {
      "and", "break", "do", "else", "elseif",
      "end", "false", "for", "function", "if",
      "in", "local", "nil", "not", "or", "repeat",
      "return", "then", "true", "until", "while",
!     "..", "...", "==", ">=", "<=", "~=",
      "<number>", "<name>", "<string>", "<eof>",
      NULL
  };
  
  
  #define save_and_next(ls) (save(ls, ls->current), next(ls))
  
  
  static void save (LexState *ls, int c) {
    Mbuffer *b = ls->buff;
--- 32,52 ----
  
  #define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
  
  
  /* ORDER RESERVED */
  const char *const luaX_tokens [] = {
      "and", "break", "do", "else", "elseif",
      "end", "false", "for", "function", "if",
      "in", "local", "nil", "not", "or", "repeat",
      "return", "then", "true", "until", "while",
!     "..", "...", "==", ">=", ">>", "<=", "<<", "^^", "~=", "!=",
      "<number>", "<name>", "<string>", "<eof>",
      NULL
  };
  
  
  #define save_and_next(ls) (save(ls, ls->current), next(ls))
  
  
  static void save (LexState *ls, int c) {
    Mbuffer *b = ls->buff;
***************
*** 366,392 ****
          else if (sep == -1) return '[';
          else luaX_lexerror(ls, "invalid long string delimiter", TK_STRING);
        }
        case '=': {
          next(ls);
          if (ls->current != '=') return '=';
          else { next(ls); return TK_EQ; }
        }
        case '<': {
          next(ls);
!         if (ls->current != '=') return '<';
!         else { next(ls); return TK_LE; }
        }
        case '>': {
          next(ls);
!         if (ls->current != '=') return '>';
!         else { next(ls); return TK_GE; }
        }
        case '~': {
          next(ls);
          if (ls->current != '=') return '~';
          else { next(ls); return TK_NE; }
        }
        case '"':
        case '\'': {
          read_string(ls, ls->current, seminfo);
          return TK_STRING;
--- 366,404 ----
          else if (sep == -1) return '[';
          else luaX_lexerror(ls, "invalid long string delimiter", TK_STRING);
        }
        case '=': {
          next(ls);
          if (ls->current != '=') return '=';
          else { next(ls); return TK_EQ; }
        }
        case '<': {
          next(ls);
!         if (ls->current == '=') { next(ls); return TK_LE; }
!         else if (ls->current == '<') { next(ls); return TK_LSHFT; }
!         else  return '<';
        }
        case '>': {
          next(ls);
!         if (ls->current == '=') { next(ls); return TK_GE; }
!         else if (ls->current == '>') { next(ls); return TK_RSHFT; }
!         else return '>';
!       }
!       case '^': {
!         next(ls);
!         if (ls->current != '^') return '^';
!         else { next(ls); return TK_XOR; }
!       }
!       case '!': {
!         next(ls);
!         if (ls->current != '=') return '!';
!         else { next(ls); return TK_NE; }
        }
        case '~': {
          next(ls);
          if (ls->current != '=') return '~';
          else { next(ls); return TK_NE; }
        }
        case '"':
        case '\'': {
          read_string(ls, ls->current, seminfo);
          return TK_STRING;
diff -rw -C 10 lua-5.1.3-orig/src/llex.h lua-5.1.3/src/llex.h
*** lua-5.1.3-orig/src/llex.h	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/llex.h	2008-03-12 06:34:00.000000000 -0600
***************
*** 21,41 ****
  * WARNING: if you change the order of this enumeration,
  * grep "ORDER RESERVED"
  */
  enum RESERVED {
    /* terminal symbols denoted by reserved words */
    TK_AND = FIRST_RESERVED, TK_BREAK,
    TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
    TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
    TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
    /* other terminal symbols */
!   TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
    TK_NAME, TK_STRING, TK_EOS
  };
  
  /* number of reserved words */
  #define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
  
  
  /* array with token `names' */
  LUAI_DATA const char *const luaX_tokens [];
  
--- 21,41 ----
  * WARNING: if you change the order of this enumeration,
  * grep "ORDER RESERVED"
  */
  enum RESERVED {
    /* terminal symbols denoted by reserved words */
    TK_AND = FIRST_RESERVED, TK_BREAK,
    TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
    TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
    TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
    /* other terminal symbols */
!   TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LSHFT, TK_LE, TK_RSHFT, TK_XOR, TK_NE, TK_CNE, TK_NUMBER,
    TK_NAME, TK_STRING, TK_EOS
  };
  
  /* number of reserved words */
  #define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
  
  
  /* array with token `names' */
  LUAI_DATA const char *const luaX_tokens [];
  
diff -rw -C 10 lua-5.1.3-orig/src/lopcodes.c lua-5.1.3/src/lopcodes.c
*** lua-5.1.3-orig/src/lopcodes.c	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/lopcodes.c	2008-03-12 06:35:25.000000000 -0600
***************
*** 25,44 ****
--- 25,51 ----
    "SETUPVAL",
    "SETTABLE",
    "NEWTABLE",
    "SELF",
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MOD",
    "POW",
+   "BOR",
+   "BAND",
+   "OP_BXOR"
+   "BLSHFT",
+   "BRSHFT",
+   "BNOT",
+   "INTDIV",
    "UNM",
    "NOT",
    "LEN",
    "CONCAT",
    "JMP",
    "EQ",
    "LT",
    "LE",
    "TEST",
    "TESTSET",
***************
*** 71,90 ****
--- 78,104 ----
   ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
   ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
   ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
   ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
   ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BOR */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BAND */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BXOR */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BLSHFT */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_RLSHFT */
+  ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_BNOT */
+  ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_INTDIV */
   ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
   ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
   ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
   ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
   ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
   ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
   ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
   ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
   ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TEST */
   ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
diff -rw -C 10 lua-5.1.3-orig/src/lopcodes.h lua-5.1.3/src/lopcodes.h
*** lua-5.1.3-orig/src/lopcodes.h	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/lopcodes.h	2008-03-12 06:37:06.000000000 -0600
***************
*** 167,186 ****
--- 167,193 ----
  OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
  
  OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
  
  OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
  OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
  OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
  OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
  OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
  OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+ OP_BOR,/*	A B C	R(A) := RK(B) | RK(C)				*/
+ OP_BAND,/*	A B C	R(A) := RK(B) & RK(C)				*/
+ OP_BXOR,/*	A B C	R(A) := RK(B) ^| RK(C)				*/
+ OP_BLSHFT,/*A B C	R(A) := RK(B) << RK(C)				*/
+ OP_BRSHFT,/*A B C	R(A) := RK(B) >> RK(C)				*/
+ OP_BNOT,/*  A B	    R(A) := ~ R(B)						*/
+ OP_INTDIV,/*A B C	R(A) := RK(B) \ RK(C)				*/
  OP_UNM,/*	A B		R(A) := -R(B)						*/
  OP_NOT,/*	A B		R(A) := not R(B)					*/
  OP_LEN,/*	A B		R(A) := length of R(B)				*/
  
  OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
  
  OP_JMP,/*	sBx	pc+=sBx					*/
  
  OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
  OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*/
diff -rw -C 10 lua-5.1.3-orig/src/lparser.c lua-5.1.3/src/lparser.c
*** lua-5.1.3-orig/src/lparser.c	2007-12-28 08:32:23.000000000 -0700
--- lua-5.1.3/src/lparser.c	2008-03-12 06:40:46.000000000 -0600
***************
*** 773,824 ****
    }
    luaX_next(ls);
  }
  
  
  static UnOpr getunopr (int op) {
    switch (op) {
      case TK_NOT: return OPR_NOT;
      case '-': return OPR_MINUS;
      case '#': return OPR_LEN;
      default: return OPR_NOUNOPR;
    }
  }
  
  
  static BinOpr getbinopr (int op) {
    switch (op) {
      case '+': return OPR_ADD;
      case '-': return OPR_SUB;
      case '*': return OPR_MUL;
      case '/': return OPR_DIV;
      case '%': return OPR_MOD;
      case '^': return OPR_POW;
      case TK_CONCAT: return OPR_CONCAT;
      case TK_NE: return OPR_NE;
      case TK_EQ: return OPR_EQ;
      case '<': return OPR_LT;
      case TK_LE: return OPR_LE;
      case '>': return OPR_GT;
      case TK_GE: return OPR_GE;
      case TK_AND: return OPR_AND;
      case TK_OR: return OPR_OR;
      default: return OPR_NOBINOPR;
    }
  }
  
  
  static const struct {
    lu_byte left;  /* left priority for each binary operator */
    lu_byte right; /* right priority */
  } priority[] = {  /* ORDER OPR */
!    {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `/' `%' */
     {10, 9}, {5, 4},                 /* power and concat (right associative) */
     {3, 3}, {3, 3},                  /* equality and inequality */
     {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
     {2, 2}, {1, 1}                   /* logical (and/or) */
  };
  
  #define UNARY_PRIORITY	8  /* priority for unary operators */
  
  
  /*
--- 773,831 ----
    }
    luaX_next(ls);
  }
  
  
  static UnOpr getunopr (int op) {
    switch (op) {
      case TK_NOT: return OPR_NOT;
      case '-': return OPR_MINUS;
      case '#': return OPR_LEN;
+ 	case '~': return OPR_BNOT;
      default: return OPR_NOUNOPR;
    }
  }
  
  
  static BinOpr getbinopr (int op) {
    switch (op) {
      case '+': return OPR_ADD;
      case '-': return OPR_SUB;
      case '*': return OPR_MUL;
      case '/': return OPR_DIV;
      case '%': return OPR_MOD;
      case '^': return OPR_POW;
+     case '|': return OPR_BOR;
+     case '&': return OPR_BAND;
+     case TK_XOR: return OPR_BXOR;
+     case TK_LSHFT: return OPR_BLSHFT;
+     case TK_RSHFT: return OPR_BRSHFT;
+     case '\\': return OPR_INTDIV;
      case TK_CONCAT: return OPR_CONCAT;
      case TK_NE: return OPR_NE;
      case TK_EQ: return OPR_EQ;
      case '<': return OPR_LT;
      case TK_LE: return OPR_LE;
      case '>': return OPR_GT;
      case TK_GE: return OPR_GE;
      case TK_AND: return OPR_AND;
      case TK_OR: return OPR_OR;
      default: return OPR_NOBINOPR;
    }
  }
  
  
  static const struct {
    lu_byte left;  /* left priority for each binary operator */
    lu_byte right; /* right priority */
  } priority[] = {  /* ORDER OPR */
!    {6, 6}, {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, /* `|' `&' `!' `<<' `>>' `\' */
     {10, 9}, {5, 4},                 /* power and concat (right associative) */
     {3, 3}, {3, 3},                  /* equality and inequality */
     {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
     {2, 2}, {1, 1}                   /* logical (and/or) */
  };
  
  #define UNARY_PRIORITY	8  /* priority for unary operators */
  
  
  /*
diff -rw -C 10 lua-5.1.3-orig/src/ltm.c lua-5.1.3/src/ltm.c
*** lua-5.1.3-orig/src/ltm.c	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/ltm.c	2008-03-12 06:41:52.000000000 -0600
***************
*** 26,46 ****
    "proto", "upval"
  };
  
  
  void luaT_init (lua_State *L) {
    static const char *const luaT_eventname[] = {  /* ORDER TM */
      "__index", "__newindex",
      "__gc", "__mode", "__eq",
      "__add", "__sub", "__mul", "__div", "__mod",
      "__pow", "__unm", "__len", "__lt", "__le",
!     "__concat", "__call"
    };
    int i;
    for (i=0; i<TM_N; i++) {
      G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
      luaS_fix(G(L)->tmname[i]);  /* never collect these names */
    }
  }
  
  
  /*
--- 26,47 ----
    "proto", "upval"
  };
  
  
  void luaT_init (lua_State *L) {
    static const char *const luaT_eventname[] = {  /* ORDER TM */
      "__index", "__newindex",
      "__gc", "__mode", "__eq",
      "__add", "__sub", "__mul", "__div", "__mod",
      "__pow", "__unm", "__len", "__lt", "__le",
!     "__concat", "__call",
!     "__or", "__and", "__xor", "__shl", "__shr", "__not", "__intdiv"
    };
    int i;
    for (i=0; i<TM_N; i++) {
      G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
      luaS_fix(G(L)->tmname[i]);  /* never collect these names */
    }
  }
  
  
  /*
diff -rw -C 10 lua-5.1.3-orig/src/ltm.h lua-5.1.3/src/ltm.h
*** lua-5.1.3-orig/src/ltm.h	2007-12-27 06:02:25.000000000 -0700
--- lua-5.1.3/src/ltm.h	2008-03-12 06:43:17.000000000 -0600
***************
*** 26,45 ****
--- 26,52 ----
    TM_MUL,
    TM_DIV,
    TM_MOD,
    TM_POW,
    TM_UNM,
    TM_LEN,
    TM_LT,
    TM_LE,
    TM_CONCAT,
    TM_CALL,
+   TM_BOR,
+   TM_BAND,
+   TM_BXOR,
+   TM_BRSHFT,
+   TM_BLSHFT,
+   TM_BNOT,
+   TM_INTDIV,
    TM_N		/* number of elements in the enum */
  } TMS;
  
  
  
  #define gfasttm(g,et,e) ((et) == NULL ? NULL : \
    ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
  
  #define fasttm(l,et,e)	gfasttm(G(l), et, e)
  
diff -rw -C 10 lua-5.1.3-orig/src/luaconf.h lua-5.1.3/src/luaconf.h
*** lua-5.1.3-orig/src/luaconf.h	2008-01-18 10:07:48.000000000 -0700
--- lua-5.1.3/src/luaconf.h	2008-03-12 06:44:36.000000000 -0600
***************
*** 527,553 ****
--- 527,560 ----
  
  /*
  @@ The luai_num* macros define the primitive operations over numbers.
  */
  #if defined(LUA_CORE)
  #include <math.h>
  #define luai_numadd(a,b)	((a)+(b))
  #define luai_numsub(a,b)	((a)-(b))
  #define luai_nummul(a,b)	((a)*(b))
  #define luai_numdiv(a,b)	((a)/(b))
+ #define luai_numintdiv(a,b)	(floor((a)/(b)))
  #define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
  #define luai_numpow(a,b)	(pow(a,b))
  #define luai_numunm(a)		(-(a))
  #define luai_numeq(a,b)		((a)==(b))
  #define luai_numlt(a,b)		((a)<(b))
  #define luai_numle(a,b)		((a)<=(b))
  #define luai_numisnan(a)	(!luai_numeq((a), (a)))
+ #define luai_logor(r, a, b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai|bi; }
+ #define luai_logand(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai&bi; }
+ #define luai_logxor(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai^bi; }
+ #define luai_lognot(r,a)	{ lua_Integer ai; lua_number2int(ai,a); r = ~ai; }
+ #define luai_logrshft(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai>>bi; }
+ #define luai_loglshft(r, a,b)	{ lua_Integer ai,bi; lua_number2int(ai,a); lua_number2int(bi,b); r = ai<<bi; }
  #endif
  
  
  /*
  @@ lua_number2int is a macro to convert lua_Number to int.
  @@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
  ** CHANGE them if you know a faster way to convert a lua_Number to
  ** int (with any rounding method and without throwing errors) in your
  ** system. In Pentium machines, a naive typecast from double to int
  ** in C is extremely slow, so any alternative is worth trying.
diff -rw -C 10 lua-5.1.3-orig/src/lvm.c lua-5.1.3/src/lvm.c
*** lua-5.1.3-orig/src/lvm.c	2007-12-28 08:32:23.000000000 -0700
--- lua-5.1.3/src/lvm.c	2008-03-12 06:47:55.000000000 -0600
***************
*** 318,345 ****
--- 318,369 ----
        (c = luaV_tonumber(rc, &tempc)) != NULL) {
      lua_Number nb = nvalue(b), nc = nvalue(c);
      switch (op) {
        case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
        case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
        case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
        case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
        case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
        case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
        case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
+       case TM_INTDIV: setnvalue(ra, luai_numintdiv(nb, nc)); break;
        default: lua_assert(0); break;
      }
    }
    else if (!call_binTM(L, rb, rc, ra, op))
      luaG_aritherror(L, rb, rc);
  }
  
  
+ static void Logic (lua_State *L, StkId ra, const TValue *rb,
+                    const TValue *rc, TMS op) {
+   TValue tempb, tempc;
+   const TValue *b, *c;
+   if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+       (c = luaV_tonumber(rc, &tempc)) != NULL) {
+     lua_Number nb = nvalue(b), nc = nvalue(c);
+     lua_Integer r;
+     switch (op) {
+       case TM_BLSHFT: luai_loglshft(r, nb, nc); break;
+       case TM_BRSHFT: luai_logrshft(r, nb, nc); break;
+       case TM_BOR: luai_logor(r, nb, nc); break;
+       case TM_BAND: luai_logand(r, nb, nc); break;
+       case TM_BXOR: luai_logxor(r, nb, nc); break;
+       case TM_BNOT: luai_lognot(r, nb); break;
+       default: lua_assert(0); r = 0; break;
+     }
+     setnvalue(ra, r);
+   }
+   else if (!call_binTM(L, rb, rc, ra, op))
+     luaG_logicerror(L, rb, rc);
+ }
+ 
  
  /*
  ** some macros for common tasks in `luaV_execute'
  */
  
  #define runtime_check(L, c)	{ if (!(c)) break; }
  
  #define RA(i)	(base+GETARG_A(i))
  /* to be used after possible stack reallocation */
  #define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
***************
*** 362,381 ****
--- 386,416 ----
          TValue *rc = RKC(i); \
          if (ttisnumber(rb) && ttisnumber(rc)) { \
            lua_Number nb = nvalue(rb), nc = nvalue(rc); \
            setnvalue(ra, op(nb, nc)); \
          } \
          else \
            Protect(Arith(L, ra, rb, rc, tm)); \
        }
  
  
+ #define logic_op(op,tm) { \
+         TValue *rb = RKB(i); \
+         TValue *rc = RKC(i); \
+         if (ttisnumber(rb) && ttisnumber(rc)) { \
+           lua_Integer r; \
+           op(r, nvalue(rb), nvalue(rc)); \
+           setnvalue(ra, r); \
+         } \
+         else \
+           Protect(Logic(L, ra, rb, rc, tm)); \
+       }
  
  void luaV_execute (lua_State *L, int nexeccalls) {
    LClosure *cl;
    StkId base;
    TValue *k;
    const Instruction *pc;
   reentry:  /* entry point */
    lua_assert(isLua(L->ci));
    pc = L->savedpc;
    cl = &clvalue(L->ci->func)->l;
***************
*** 495,514 ****
--- 530,585 ----
          TValue *rb = RB(i);
          if (ttisnumber(rb)) {
            lua_Number nb = nvalue(rb);
            setnvalue(ra, luai_numunm(nb));
          }
          else {
            Protect(Arith(L, ra, rb, rb, TM_UNM));
          }
          continue;
        }
+       case OP_BOR: {
+         logic_op(luai_logor, TM_BOR);
+         continue;
+       }
+       case OP_BAND: {
+         logic_op(luai_logand, TM_BAND);
+         continue;
+       }
+       case OP_BXOR: {
+         logic_op(luai_logxor, TM_BXOR);
+         continue;
+       }
+       case OP_BLSHFT: {
+         logic_op(luai_loglshft, TM_BRSHFT);
+         continue;
+       }
+       case OP_BRSHFT: {
+         logic_op(luai_logrshft, TM_BRSHFT);
+         continue;
+       }
+       case OP_BNOT: {
+         TValue *rb = RB(i);
+         if (ttisnumber(rb)) {
+           lua_Integer r;
+           luai_lognot(r, nvalue(rb));
+           setnvalue(ra, r);
+         }
+         else {
+           Protect(Logic(L, ra, rb, rb, TM_BNOT));
+         }
+         continue;
+       }
+       case OP_INTDIV: {
+         arith_op(luai_numintdiv, TM_DIV);
+         continue;
+       }
        case OP_NOT: {
          int res = l_isfalse(RB(i));  /* next assignment may change this value */
          setbvalue(ra, res);
          continue;
        }
        case OP_LEN: {
          const TValue *rb = RB(i);
          switch (ttype(rb)) {
            case LUA_TTABLE: {
              setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
